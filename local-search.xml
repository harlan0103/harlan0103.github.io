<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>可靠数据传输</title>
    <link href="/2020/05/13/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/05/13/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p><strong>可靠数据传输：</strong> 传输数据由一条可靠信道进行传输，传输数据比特不会受到损坏 (由0变成1，或者相反) 或丢失，而且所有数据都是按照其发送顺序进行交付。</p><p>实现可靠传输服务抽象是<strong>可靠数据传输协议(reliable data transfer protocol)</strong> 的责任。可靠数据传输协议的下层协议也许是不可靠的。比如TCP是在不可靠的IP端到端网络层之上实现的可靠数据传输协议。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589175602/Computer_Network/reliable_data_transfer_protocol_updcvb.png" srcset="/img/loading.gif" alt="Reliable_Data_Transfer_Protocol"></p><p>a) 对于运输层内的可靠信道，进程可以直接通过可靠信道进行分组交换</p><p>b) 对于底层的不可靠传输，进程需要在运输层使用可靠数据传输协议来放置比特丢失或翻转</p><p><strong>可靠数据传输协议服务实现</strong></p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589175935/Computer_Network/%E5%9B%BE%E7%89%871_h9z8o7.png" srcset="/img/loading.gif" alt="RDT_Service"></p><ul><li><code>redt_send()</code>：由数据发送方进程调用，向可靠数据传输协议较高层发送数据</li><li><code>udt_send()</code>： 由rdt调用，将数据通过不可靠信道传输给接收方</li><li><code>rdt_rcv()</code>：由接收方的rdt调用，从不可靠信道中取出到达的分组</li><li><code>deliver_data()</code>：由接收方的rdt调用，负责将分组中的数据发送给用户进程</li></ul><h2 id="构造可靠传输协议"><a href="#构造可靠传输协议" class="headerlink" title="构造可靠传输协议"></a>构造可靠传输协议</h2><h3 id="经完全可靠信道的可靠数据传输：rdt1-0"><a href="#经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt1.0"></a>经完全可靠信道的可靠数据传输：rdt1.0</h3><p>首先考虑最简单的情况，即<strong>底层信道是完全可靠的</strong>。我们称该协议为 rdt1.0，该协议本身是简单的。</p><p>因为底层信道是完全可靠的，所以发送方和接收放不用担心分组是否会有翻转和丢失的情况出现。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589178727/Computer_Network/rdt1.0_zuyrti.png" srcset="/img/loading.gif" alt="rdt1.0"></p><p><strong>发送端：</strong> rdt通过<code>rdt_send(data)</code>从用户进程接收到数据后，通过<code>make_pkt(data)</code>将数据打包产生一个包含该数据的分组，并将分组发送到信道中。</p><p><strong>接收端：</strong> rdt通过<code>rdt_rcv(packet)</code>从信道中接收到分组，通过<code>extract(packet,data)</code>取出数据，并将数据向上层用户进程发送。</p><p>因为是完全可靠的信道，所有接收端就不需要提供任何反馈信息给发送方。</p><h3 id="经具有比特差错信道的可靠数据传输：rdt2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt2.0"></a>经具有比特差错信道的可靠数据传输：rdt2.0</h3><p>底层信道更为实际的模型是<strong>分组中的比特可能受损</strong>的模型。我们眼下还将继续假定所有发送的分组将按其发送的顺序被接收。</p><p>当发送端向接收端发送数据时，如果接收端收到的数据受损，那么接收端可能需要向发送端表明收到的数据受损，并要求发送端再次发送数据。这样的机制叫做重传机制。而基于重传机制的可靠数据传输协议称为<strong>自动重传请求(Automatic Repeat reQuest, ARQ)协议</strong>。</p><p>ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：</p><ol><li><strong>差错检测</strong>：首先，需要使用一种机制来使接收方检测何时出现了比特差错。一种方法就是使用比特检验和来对分组进行比对。</li><li><strong>接收方反馈</strong>：在出现比特差错后，接收方需要向发送方提供反馈。常见的反馈信息有<strong>ACK(肯定确认)</strong>和<strong>NAK(否定确认)</strong>分组。</li><li><strong>重传</strong>：接收方收到有差错的分组时，发送方将重传该分组报文。</li></ol><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589179755/Computer_Network/rdt2.0_qjbdrq.png" srcset="/img/loading.gif" alt="rdt2.0"></p><p><strong>发送方：</strong> rdt通过<code>rdt_send(data)</code>从用户进程接收数据，之后通过<code>make_pkt(data, checksum)</code>将数据和检验和打包产生一个包含该数据的分组，并将分组发送到信道中。</p><p>当分组发送后，发送端将进入等待接收端反馈的阶段。发送方协议等待来自接收方的ACK或NAK分组。如果<code>rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt)</code>为真，那么表示接收端没有收到正确的分组，发回了<code>NAK</code>的反馈，此时发送方需要再次发送该分组。</p><p>而如果<code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code>为真，表示接收端收到了分组，则可以继续等待用户进程发送数据。</p><p><strong>接收方：</strong> rdt首先通过<code>rdt_rcv(rcvpkt)</code>从信道获取分组，之后检查该分组是否存在比特损坏的情况。如果有，那么调用<code>udt_send(NAK)</code>来告知发送方重新发送分组。如果接收方收到的分组是完整的，那么取出数据并上传至用户进程后再向发送方进行反馈，<code>udt_send(ACK)</code>。</p><blockquote><p>在rdt2.0协议中，发送方在发出分组后会一直等待接收方的反馈。直到收到接收方的反馈后才会进行下一步。这种协议被称为<strong>停等(stop-and-wait)协议</strong>。</p></blockquote><h4 id="ACK-NAK-分组受损的-rtd2-1"><a href="#ACK-NAK-分组受损的-rtd2-1" class="headerlink" title="ACK/NAK 分组受损的 rtd2.1"></a>ACK/NAK 分组受损的 rtd2.1</h4><p>rdt2.0协议存在一个致命的缺陷，那就是 <strong>ACK/NAK 分组可能会受损</strong>。当 ACK/NAK 受损时，发送方无法直到接收方的正确反馈。</p><p>一种对于受损ACK/NAK分组的解决方法是：发送方再次发送同样的分组。但因为此时接收方不知道收到的分组是新的分组还是一次重传分组，所以这种解决方法会产生<strong>冗余分组(duplicate packet)</strong>。</p><p>解决<strong>冗余分组</strong>的方法就是在数据分组中添加一个新的字段，该字段保存了这一分组在发送方的编号。于是，接收方只需要检查该序列号就可以确定收到的分组是否为一次重传。对于停等协议来说，只需要1比特，即0和1就可以分别当前分组是否为当前分组还是上一个已经收到的分组。</p><p>此时每一个分组都有一个0或这1来表示其序列号，且当前序列号与前一个发送的分组是不同的。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589182084/Computer_Network/rdt2.0_send_sontey.png" srcset="/img/loading.gif" alt="rdt2.1_send"></p><p><strong>发送方：</strong> 发送端首先获取序号为0的数据并生成分组后向接收端发送。之后等待接收方的反馈。</p><p>如果收到的是ACK，那么发送方会等待用户进程发送序号为1的数据。</p><p>如果收到的是NAK或者受损的ACK/NAK包，那么发送方会再次向接收方发送分组0。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589182084/Computer_Network/rdt2.1_receiver_huig5c.png" srcset="/img/loading.gif" alt="rdt2.1_receiver"></p><p><strong>接收方：</strong> 当接收方第一次收到分组0时会有两种情况，第一种是收到了分组0，第二种是分组0受损。如果收到了分组0，这时候会取出数据并向发送方发送一个ACK，并等待分组1的到来。如果分组受损则会向发送方发送一个NAK包。</p><p>在发送方收到了接收方的反馈后，如果反馈没有受损，那么发送方会向接收方发送分组1。此时双方通信都没有受损的分组，通信正常。</p><p>如果发送方收到的ACK受损，那么发送方会重复向接收方发送分组0，这时候接收方正在等待分组1，所以只会向发送方发送ACK包，而不会再次取出分组0中的数据，一面重复。</p><p>如果发送方收到的是NAK包，那么发送方会重复向接收方发送分组0，而接收方收到分组0后会取出数据并向发送方发送ACK包。此时对于分组0的交换完成。接收方等待分组1的到来。</p><p><strong>因为目前假定信道不会丢分组，ACK和NAK分组本身不需要指明它们要确认的分组序号</strong>。</p><h4 id="只有ACK分组的-rdt2-2"><a href="#只有ACK分组的-rdt2-2" class="headerlink" title="只有ACK分组的 rdt2.2"></a>只有ACK分组的 rdt2.2</h4><p>rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。这时ACK分组将会使用0或1表示其属于哪一个分组的反馈。如果收到受损的分组，则接收方将发送一个对上次正确接收的分组发送一个ACK，以此来实现和NAK相同的效果。</p><p>如果接收方收到的ACK与发送的ACK分组序号不相符，那么就表示接收方没有收到正确的分组，所以重新发送。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589185212/Computer_Network/rdt2.2_w8mle7.png" srcset="/img/loading.gif" alt="rdt2.2"></p><h3 id="经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h3><p>现在假定除了比特受损外 <strong>(发送方能够收到接收方的反馈，无论是ACK还是损坏的分组)</strong>，底层信道还会丢包，这在今天的计算机网络中并不罕见。</p><p>这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的相应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。</p><p>发送方应当选择一个时间值来判断是否发生了丢包。如果在这个时间内没有收到ACK或受损分组，则应当重传该分组。</p><p>对于发送方来说，不论是数据分组丢失，还是ACK丢失，或者值时分组或ACK过度延时。在所有这些情况下，动作是同样的：重传。为了实现重传机制，需要一个<strong>倒计数定时器 (countdown timer)</strong>，在一个给定的时间量过期后，可中断发送方。</p><p>发送方需要做到：1.每次发送一个分组时，便启动一个定时器。2.相应定时器中断。3.终止定时器。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589186294/Computer_Network/rdt3.0_fmguol.png" srcset="/img/loading.gif" alt="rdt3.0_sender"></p><p><strong>发送方：</strong> 发送方向接收方发送分组0之后，启动计时器并等待接收方的ACK分组。如果接收方收到分组0且返回ACK0，那么发送方准备发送分组1。</p><p>如果接收方收到了分组0，但分组0损坏，则向发送方发送ACK1。此时发送方会停止计时器，并再次向接收方发送分组0。</p><p>如果接收方没有收到分组0，或者ACK0在传输过程中丢包，导致计时器超时，那么发送方会再次向接收方发送当前分组0。</p><p>接收方会根据分组的序号来判断当前分组是否为重复分组。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589186294/Computer_Network/rdt3.0_example1_ezmwyx.png" srcset="/img/loading.gif" alt="rdt3.0_example1"></p><p>a) 发送方和接收方都没有丢包，则传输正常。</p><p>b) 发送方在发送分组1时出现丢包，此时接收方收不到任何分组，则不会向发送方发送反馈。在超时后，发送方会再次发送分组1。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589186295/Computer_Network/rdt3.0_example2_pl3dok.png" srcset="/img/loading.gif" alt="rdt3.0_example2"></p><p>c) 发送方成功发送了分组1，且接收方收到了分组1，但是ACK1分组丢失。此时发送方发送了分组1一段时间后仍收不到任何反馈，于是再次发送分组1。此时接收方识别到新到来的分组1是重复分组，于是向发送方再次发送ACK1。</p><p>d) 发送方成功发送了分组1，接收方也发送了ACK1，但是由于大延时发送方没有在时限内收到ACK1。于是发送方重新发送了分组1。在发送了分组1之后发送方收到了ACK1分组，这时候发送方开始发送分组0。对于接收方来说，第二次收到分组1时因为是重复分组，所以再次向发送方发送了ACK1。而收到了新的分组0后，向发送方发送了ACK0分组。发送方第二次收到了ACK1的分组，于是再次向接收方发送了分组0。这样再第一次时延之后，发送方和接收方会重复发送相同的分组。</p><h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>rdt3.0是一个功能正确的协议。但是rdt3.0性能问题的核心在于它是一个停等协议。也就是说发送方必须获得接收方的反馈后才能发送新的分组。</p><p>发送方发送一个分组后还要承受数据到达接收方以及接收方返回反馈分组的时延，所以即便链路的吞吐量很大，效率仍然很低。</p><p>对于这种性能问题的解决方法是：<strong>不以停等的方式运行，允许发送方发送多个分组而无需等待确认</strong>。</p><p>因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为<strong>流水线 (pipelining)</strong>。</p><p>流水线技术对可靠数据传输协议可带来如下影响：</p><ul><li>必须增加序号范围，因为每个输送中的分组必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。</li><li>协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方需要缓存那些已正确接收的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏以及延时过大的分组。解决流水线的差错恢复有两种方法：<strong>回退N步</strong>和<strong>选择重传</strong>。</li></ul><h3 id="回退N步-Go-Back-N-GNB"><a href="#回退N步-Go-Back-N-GNB" class="headerlink" title="回退N步 Go-Back-N, GNB"></a>回退N步 Go-Back-N, GNB</h3><p>在回退N步协议中，允许发送方发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589334264/Computer_Network/GBN_window_cee2gj.png" srcset="/img/loading.gif" alt="GBN_window"></p><ul><li>窗口由N个分组组成</li><li>base前的窗口表示发送且已被确认的分组</li><li>base到nextseqnum之间的分组表示已发送还未被确认的分组</li><li>nextsequm到base+N-1之间的分组表示可以使用但还未发送的分组</li><li>base+N-1之后的分组表示不可用分组</li></ul><p>GBN也被称为<strong>滑动窗口协议 (sliding-window protocol)</strong></p><p><strong>GBN 发送方：</strong></p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589334336/Computer_Network/GBN_sender_w5xtjf.png" srcset="/img/loading.gif" alt="GBN_FSM"></p><ul><li><p>发送方首先检查下一个分组是否在窗口内，<code>nextseqnum &lt; base+N</code>，如果超出了窗口的范围，则通知上层进程取消数据传递。如果在范围内，且要发送的分组是窗口的第一个分组时，开始计时器。同时增加nextseqnum。</p></li><li><p>当长时间未收到任何接收方反馈时，则重新启动计时器，并发送窗口内所有已发送但未确认的分组。</p></li><li><p>在GBN协议中，对序号为n的分组的确认采取<strong>累计确认(cumulative acknowledgement)</strong>方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。</p></li><li><p>当接收到一个ACK时，将base向后移动一位，表示整个窗口都向后移动。并且重设计时器。</p></li></ul><p><strong>GBN 接收方：</strong></p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589334820/Computer_Network/GBN_rcv_z9r6su.png" srcset="/img/loading.gif" alt="GBN_RCV"></p><ul><li><p>如果一个序号为n的分组被正确接收到，并且按序，则接收方为分组n发送一个ACK，并且将该分组中的数据全部交付到上层。</p></li><li><p>在所有其他情况下，接收方丢弃该分组，并为<strong>最近按序接收的分组</strong>重新发送ACK。</p></li></ul><p><strong>接收方只需要维护的信息是下一个按序接收的分组的序号。发送方强制接收方按照发送顺序接收分组。</strong></p><p><strong>GBN例子：</strong></p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589335100/Computer_Network/GBN_in_action_z2gtq1.png" srcset="/img/loading.gif" alt="GBN_in_action"></p><ul><li><p>此时发送方的窗口长度为4，则发送方会依次发送前4个分组。</p></li><li><p>接收方首先正确的接收到了分组0和分组1，且向发送方反馈了ACK。发送方的窗口被向后移动。</p></li><li><p>分组2并没有到达接收方且丢包。同时发送方又向接收方发送了分组3，4，5。此时接收方缓存了下一个按序接收的分组的序号为2，所以其他任何分组都将被丢弃，且接收方会向发送方反馈重复的分组1ACK。</p></li><li><p>当分组2的计时器超时后，发送方将重新从第一个发送但没有确认的分组开始发送，这里是分组2。所以发送方将重新发送分组2，3，4，5。</p></li><li><p>当窗口内的所有分组都被发送完后，发送方需要等待接收方反馈ACK分组，以此来移动窗口，继续发送。</p></li></ul><h3 id="选择重传-Selective-Repeat"><a href="#选择重传-Selective-Repeat" class="headerlink" title="选择重传 Selective Repeat"></a>选择重传 Selective Repeat</h3><p>GBN存在的问题在于单个分组的出错会导致大量的分组重传。</p><p>选择重传协议通过让发送方仅重传那些它怀疑在接收方面出错的分组而避免了不必要的重传。</p><p>这种个别的，按需的重传要求接收方逐个地确认正确接收地分组。</p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589338500/Computer_Network/SR_jwwlpu.png" srcset="/img/loading.gif" alt="SR"></p><ul><li><p>在发送方窗口内，有一部分的分组被接收，而有一部分的分组已发送但未确认</p></li><li><p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢分组皆被收到为止。</p></li><li><p>接收方收到分组后会将窗口移动</p></li></ul><p><strong>SR 例子：</strong></p><p><img src="https://res.cloudinary.com/harlan9613/image/upload/v1589338849/Computer_Network/sr_in_action_xppm3h.png" srcset="/img/loading.gif" alt="SR_in_action"></p><ul><li><p>发送方首先发送 0，1，2，3 分组。发送完当前窗口内的所有分组后发送方等待。</p></li><li><p>接收方收到分组 0，1 并反馈ACK，同时分组 2 丢失。此时接收方窗口内为 2，3，4，5。在收到分组3后将分组3的内容缓存</p></li><li><p>发送方收到分组 0，1 的ACK分组后，移动窗口，发送分组 4，5</p></li><li><p>接收方收到分组 4，5。因为分组2丢失，所以同样接收方缓存分组 4，5。并向发送方发送分组 4，5 的ACK。</p></li><li><p>此时发送方分组2的计时器超时，发送方重新发送分组2。之后分组 4，5 的ACK已经到达。但是因为分组2的ACK没有收到，所以发送方窗口无法移动。</p></li><li><p>接收方收到了分组2，于是分组 2，3，4，5 可以按照顺序交付，同时接收方的窗口移动至 6，7，8，9</p></li><li><p>发送方收到分组2的ACK后，可以移动窗口至 6，7，8，9。传输继续。</p></li></ul><p>因为在SR中，发送方和接收方窗口有可能是不同步的。因为如果接收方收到分组，但是发送方丢失ACK分组时，接收方的窗口会移动，但是发送方窗口不会移动。所以在有限的分组序号中，<strong>如果接收窗口过大的话</strong>，很可能出现发送方重传分组和接收方等待新分组的序号是相同的。</p><p>所以对于SR协议而言，<strong>窗口长度必须小于或等于序号空间大小的一半</strong>。假设当前接收窗口起始地址在序号空间的中心，如果窗口大小大于一半，那么窗口会覆盖序号空间的后半部分和少量前半部分。如果之前分组的ACK丢失的话，发送方的窗口还会留在序号空间的前一半。这样会出现接收方等待的新分组的序号和发送方将要重传分组的序号相同。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此部分中学习了运输层协议能够提供可靠数据传输，即使下面的网络层是不可靠的。我们应该理解在链路层，网络层，运输层或应用层协议中都可以提供可靠运输传送。该协议栈中上面4层的任意一层都可以实现<strong>确认，定时器，重传以及序号</strong>，能够向其上层提供可靠数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>减小Electron应用打包后的体积</title>
    <link href="/2020/02/11/%E5%87%8F%E5%B0%8FElectron%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BD%93%E7%A7%AF/"/>
    <url>/2020/02/11/%E5%87%8F%E5%B0%8FElectron%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BD%93%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p>Electron可以说是给那些对前端技术比较熟悉的开发人员进行桌面应用开发的一个比较好的框架<br>但是Electron打包之后的文件大小实在是有点过于庞大，对于一个没有太多功能的app居然达到了300mb！<br>在对打包后的文件进行查询后发现占用体积最大的部分就是React应用中的<code>node_modules</code><br>因为使用的是<code>electron-packager</code>进行的打包，所以打包后的程序基本上是完整拷贝了<code>node_modules</code>中的所有文件<br>但是除了React的那部分外，还有很大的一部分空间被占用了</p><blockquote><p>The downside of the Electron approach is that each app comes with a copy of two large software frameworks, Node.js and Chromium.<br>So, each Electron app essentially carries an operating system with it.</p></blockquote><p>就像<a href="https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297" target="_blank" rel="noopener">Put your Electron app on a diet with Electrino</a>这篇文章讲的那样，因为Electron的内核使用的是<code>Chromium</code>同时还加载了所有的<code>node_modules</code>，基本上一款Electron应用里面就用到了两大框架，所以即便是一个简单的<code>hello_world.js</code>被Electron打包出来后都会有100mb以上的大小</p><h3 id="减小node-modules的体积"><a href="#减小node-modules的体积" class="headerlink" title="减小node_modules的体积"></a>减小node_modules的体积</h3><p>因为<code>Chromium</code>内核的文件是不能删除的，而在打包过程中产生的文件也是不能删掉的，所以比较现实的方法就是尽可能的减少<code>node_modules</code>里面的文件</p><h4 id="删除多余的package"><a href="#删除多余的package" class="headerlink" title="删除多余的package"></a>删除多余的package</h4><p>在开发的过程中，有可能会使用一些新的依赖项来顶替掉原来使用的依赖项，这个时候<code>node_modules</code>就会越来越大，所以在<code>package.json</code>文件中会有一大长串的<code>dependencies</code>，但是在应用中却没有被引用<br>这时候就需要清理<code>node_modules</code>，比较暴力的方法就是删除整个文件，然后<code>npm install</code>来安装所有在<code>package.json</code>中的依赖项。同时也可以使用<code>npm prune --</code>指令<br><code>prune</code>主要是来移除无关的包，可以提供需要被移除的包名</p><pre><code>npm prune [[&lt;@scope&gt;/]&lt;pkg&gt;...] [--production] [--dry-run] [--json]</code></pre><h4 id="将dependencies转移devDependencies中"><a href="#将dependencies转移devDependencies中" class="headerlink" title="将dependencies转移devDependencies中"></a>将dependencies转移devDependencies中</h4><p>在安装一个包的时候，可以有以下两种方法</p><pre><code>npm install module-name --savenpm install module-name --save-dev</code></pre><p>第一种是将模块安装到<code>dependencies</code>中<br>第二种是将模块安装到<code>devDependencies</code>中</p><p>dependencies代表的是生产环境，也就是程序运行时所需要调用到的包<br>而devDependencies代表的是开发环境，可以理解为开发程序中所需要的包</p><p>比如Electron就是开发环境，我们需要Electron来将我们的React App打包成桌面应用，但是我们在运行我们的桌面应用时是不需要Electron的，所以Electron可以被放在<code>devDependencies</code><br>再或者<code>react-router</code>，是React应用进行页面跳转用的模块，因为我们程序运行需要页面跳转，如果程序无法调用到这个模块，那就会报错，所以这个模块就是生产环境</p><p>在Electron打包的过程中，是不会将<code>devDependencies</code>中的模块复制到打包文件中的，所以将一些开发用的模块放到<code>devDependencies</code>中也可以起到减小最终程序大小的效果</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>还有一些方法比如<code>electron-builder</code>的two package.json方法，因为我使用的不是这个打包方式，所以也不太清楚这种方法的效果<br>另一种方法是之前提到的文章的作者开发了一款叫做<code>Electrino</code>的框架，用的是操作系统自带的浏览器内核，比如Windows系统就使用的是Microsoft Edge Browser来作为内核，但是由于这个框架还在开发中，有很多api都不太全，但是可以一试</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，使用Electron这种跨平台框架来开发桌面应用本来就是一中不算太正确或者不太成熟的做法，毕竟很多桌面开发框架都很成熟而且速度很快。但Electron的确给熟悉前端技术的开发者一个好的平台来开发桌面应用<br>毕竟省去了搞服务器和公共域名的麻烦，而且也不用用户自己输入<code>npm start</code>来运行Web app</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297" target="_blank" rel="noopener">https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297</a><br><a href="https://stackoverflow.com/questions/47597283/electron-package-reduce-the-package-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/47597283/electron-package-reduce-the-package-size</a><br><a href="https://stackoverflow.com/questions/21122342/how-to-clean-node-modules-folder-of-packages-that-are-not-in-package-json" target="_blank" rel="noopener">https://stackoverflow.com/questions/21122342/how-to-clean-node-modules-folder-of-packages-that-are-not-in-package-json</a><br><a href="https://www.jianshu.com/p/de3f9a53d2a9" target="_blank" rel="noopener">https://www.jianshu.com/p/de3f9a53d2a9</a></p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React中input标签-受控组件</title>
    <link href="/2020/02/10/React%E4%B8%ADinput%E6%A0%87%E7%AD%BE-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/02/10/React%E4%B8%ADinput%E6%A0%87%E7%AD%BE-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Reference:<br><a href="https://segmentfault.com/a/1190000002675685" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002675685</a><br><a href="https://segmentfault.com/q/1010000008144015" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008144015</a><br><a href="https://stackoverflow.com/questions/43556212/failed-form-proptype-you-provided-a-value-prop-to-a-form-field-without-an-on" target="_blank" rel="noopener">https://stackoverflow.com/questions/43556212/failed-form-proptype-you-provided-a-value-prop-to-a-form-field-without-an-on</a><br><a href="http://shouce.jb51.net/react/tips/controlled-input-null-value.html" target="_blank" rel="noopener">http://shouce.jb51.net/react/tips/controlled-input-null-value.html</a></p><p>今天在做一个用户能够更新数据的表单的时候遇到了几个问题</p><h3 id="input-受控组件"><a href="#input-受控组件" class="headerlink" title="input 受控组件"></a>input 受控组件</h3><p>在表单中有一个<code>input</code>标签，我希望是在页面加载的时候首先从后端数据库获取当前页面对应的数据，并将某个数据放入这个<code>input</code>标签中。<br>之后用户能够更改这个<code>input</code>的value并且能够将表单中所有更新的值都在数据库端进行更新。</p><p>在给<code>&lt;input value={this.state.value}&gt;</code>赋值之后控制台出现了以下的warning</p><blockquote><p>Warning: A component is changing an uncontrolled input of type text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component.</p></blockquote><p>随即查了一下。所谓<code>controlled component - 受控组件</code>在这里指的就是被赋了值的<code>input</code>标签，也就是:</p><pre><code class="html">&lt;input value={this.state.some_value}&gt;</code></pre><p>这时候组件受控，所以<code>input</code>标签中会一直显示所赋予的值。<br>当页面被渲染之后，用户是无法更改<code>input</code>标签中的值的，这也是我尝试去删除或者修改这个<code>input</code>标签都无效的原因</p><p>如果想要随着用户的输入而改变值的话，可以使用<code>onChange</code>事件:</p><pre><code class="html">&lt;input value={this.state.some_value} onChange={e =&gt; this.setState({some_value: e.target.value})}&gt;</code></pre><p>这样，<code>input</code>标签就是可以更改的了，而且能够跟着用户的输入来更改<code>state</code>中对应的值</p><p>后来在添加了<code>onChange</code>事件后发现仍然无法删除或者修改<code>input</code>中的内容，并且控制台也没有任何报错或者警告<br>查找了半天后发现原来<code>input</code>标签中赋值的对象和<code>onChange</code>事件中改变值后更新的对象不是同一个<br>也就是每次被修改的并不是<code>input</code>内的值，所以才会出现无论怎么改动值都不会更新的情况</p><h3 id="input-defaultValue"><a href="#input-defaultValue" class="headerlink" title="input defaultValue"></a>input defaultValue</h3><p>后来在给一个<code>input</code>设置默认且不能更改的值时遇到了以下warning:</p><blockquote><p>Warning: Failed prop type: You provided a <code>value</code> prop to a form field without an <code>onChange</code> handler. This will render a read-only field. If the field should be mutable use <code>defaultValue</code>. Otherwise, set either <code>onChange</code> or <code>readOnly</code>.</p></blockquote><p>这里是当一个<code>input</code>标签中的内容不会被用户所更改时，应该将<code>value</code>改成<code>defaultvalue</code>以此来达到read-only的效果<br>如果用户需要对这个标签进行修改那么就像之前说的那样加上<code>onChange</code>事件</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm安装electron时卡在node install.js的解决办法</title>
    <link href="/2020/02/07/npm%E5%AE%89%E8%A3%85electron%E6%97%B6%E5%8D%A1%E5%9C%A8node-install-js%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2020/02/07/npm%E5%AE%89%E8%A3%85electron%E6%97%B6%E5%8D%A1%E5%9C%A8node-install-js%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在使用npm安装electron时出现了卡在<code>node install.js</code>指令的情况<br>不出意外应该是electron的安装源被墙掉了，所以需要给npm指定镜像的安装地址</p><p>解决方法是在<code>~/.npmrc</code>文件中添加如下指令即可</p><pre><code>; registry=https://registry.npm.taobao.org; electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></pre><p><code>~/.npmrc</code>是npm的配置文件，如果不知道位置可以通过如下指令直接修改</p><pre><code>npm config edit</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Electron封装React为桌面程序</title>
    <link href="/2020/02/07/%E7%94%A8Electron%E5%B0%81%E8%A3%85React%E4%B8%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/02/07/%E7%94%A8Electron%E5%B0%81%E8%A3%85React%E4%B8%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://blog.csdn.net/qq_25881261/article/details/81559794" target="_blank" rel="noopener">https://blog.csdn.net/qq_25881261/article/details/81559794</a><br><a href="https://segmentfault.com/a/1190000014030465" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014030465</a><br><a href="https://www.electronjs.org/docs/tutorial/first-app" target="_blank" rel="noopener">https://www.electronjs.org/docs/tutorial/first-app</a><br><a href="https://github.com/electron/electron-packager" target="_blank" rel="noopener">https://github.com/electron/electron-packager</a></p><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>使用React可以很高效得来做网页开发，但是在无法将React项目部署到服务器上时，让用户在cmd中输入启动React项目的指令来运行网页是不现实的<br>好在有Electron，可以将React项目封装成为桌面应用。对于用户来说使用起来更加得简单</p><h3 id="Electron简介"><a href="#Electron简介" class="headerlink" title="Electron简介"></a>Electron简介</h3><p>引用官方文档介绍</p><blockquote><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p></blockquote><h3 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h3><p>官方文档的推荐安装方法是将<code>electron</code>安装为项目的开发依赖项，这样可以在不同的app中使用不同的electron版本</p><pre><code class="bash">npm install --save-dev electron</code></pre><h2 id="在React项目中添加Electron"><a href="#在React项目中添加Electron" class="headerlink" title="在React项目中添加Electron"></a>在React项目中添加Electron</h2><h3 id="配置main-js"><a href="#配置main-js" class="headerlink" title="配置main.js"></a>配置main.js</h3><p>首先在React项目下创建一个<code>main.js</code>文件<br>项目结构类似于:</p><pre><code>---node_modules---public---src---main.js  //新建文件---package.json---package-lock.json---README.md</code></pre><p>在<code>main.js</code>中复制文档中的代码段来配置桌面应用的启动与关闭</p><blockquote><p><a href="https://www.electronjs.org/docs/tutorial/first-app" target="_blank" rel="noopener">https://www.electronjs.org/docs/tutorial/first-app</a></p></blockquote><pre><code class="javaScript">const { app, BrowserWindow } = require(&#39;electron&#39;)function createWindow () {     // 创建浏览器窗口  const win = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      nodeIntegration: true    }  })  // 加载build文件中的index.html  /*  win.loadURL(url.format({    pathname: path.join(__dirname, &#39;./build/index.html&#39;),    protocol: &#39;file:&#39;,    slashes: true  }))  */  // 加载React应用 -热更新中使用  // win.loadURL(&#39;http://localhost:3000/&#39;);  // and load the index.html of the app.  win.loadFile(&#39;index.html&#39;)  // 打开开发者工具  win.webContents.openDevTools()}// This method will be called when Electron has finished// initialization and is ready to create browser windows.// 部分 API 在 ready 事件触发后才能使用。app.whenReady().then(createWindow)// Quit when all windows are closed.app.on(&#39;window-all-closed&#39;, () =&gt; {  // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，  // 否则绝大部分应用及其菜单栏会保持激活。  if (process.platform !== &#39;darwin&#39;) {    app.quit()  }})app.on(&#39;activate&#39;, () =&gt; {  // 在macOS上，当单击dock图标并且没有其他窗口打开时，  // 通常在应用程序中重新创建一个窗口。  if (BrowserWindow.getAllWindows().length === 0) {    createWindow()  }})// In this file you can include the rest of your app&#39;s specific main process// code. 也可以拆分成几个文件，然后用 require 导入。</code></pre><p>如果是在React开发过程中需要查看electron更新需要使用<code>win.loadURL(&#39;http://localhost:3000/&#39;);</code>表示桌面文件会调用<code>localhost:3000</code>运行的内容<br>如果是要调用打包好的React项目，那么需要使用<code>win.loadURL(url.format({pathname: path.join(__dirname, &#39;./build/index.html&#39;)})),</code>来调用<code>build</code>文件夹中的<code>index.html</code></p><h3 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h3><p>因为React项目是使用<code>npm start</code>来启动，所以我们需要在<code>package.json</code>文件中配置Electron的启动指令</p><pre><code class="json">{  &quot;name&quot;: &quot;window-app&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  &quot;homepage&quot;: &quot;.&quot;,      // &quot;homepage&quot;保证build后的React项目可以运行  &quot;main&quot;: &quot;main.js&quot;,    // 在此处添加main.js  &quot;dependencies&quot;: {    &quot;@testing-library/jest-dom&quot;: &quot;^4.2.4&quot;,    &quot;@testing-library/react&quot;: &quot;^9.4.0&quot;,    &quot;@testing-library/user-event&quot;: &quot;^7.2.1&quot;,    &quot;react&quot;: &quot;^16.12.0&quot;,    &quot;react-dom&quot;: &quot;^16.12.0&quot;,    &quot;react-scripts&quot;: &quot;3.3.1&quot;  },  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;,    &quot;electron-start&quot;: &quot;electron .&quot;,     // electron启动指令    &quot;package&quot;: &quot;electron-packager C:/Users/liang/Desktop/test/window-app win-app&quot;   // electron打包指令  },  &quot;eslintConfig&quot;: {    &quot;extends&quot;: &quot;react-app&quot;  },  &quot;browserslist&quot;: {    &quot;production&quot;: [      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ],    &quot;development&quot;: [      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ]  },  &quot;devDependencies&quot;: {    &quot;electron&quot;: &quot;^8.0.0&quot;,    &quot;electron-packager&quot;: &quot;^14.2.0&quot;  }}</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>在两个命令行窗口中分别运行</p><pre><code>npm start</code></pre><pre><code>npm run electron-start</code></pre><p>这样就可以看到electron生成的桌面应用，并且是保持React项目的热更新</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="打包React"><a href="#打包React" class="headerlink" title="打包React"></a>打包React</h3><p>在开发完React项目后需要需要将项目打包以此来是的electron桌面程序能够脱离服务器来使用<br>这里需要在<code>package.json</code>文件中添加<code>&quot;homepage&quot;:&quot;.&quot;</code>来保证所有的路径都能被访问到<br>打包React:<br><code>npm run build</code><br>打包后会在当前目录下创建<code>build</code>文件夹，打开文件夹后运行<code>index.html</code>，如果出现内容则证明React项目打包成功</p><h3 id="打包Electron"><a href="#打包Electron" class="headerlink" title="打包Electron"></a>打包Electron</h3><p>官方文档上说常用的打包插件有<code>electron-forg</code>,<code>electron-packager</code>和<code>electron-builder</code><br>这里使用<code>electron-packager</code><br>首先安装</p><pre><code>npm install electron-packager --save-devnpm install electron-packager -g</code></pre><p>electron-packager的指令是：</p><pre><code>electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</code></pre><p>这里可以简化并添加到<code>package.json</code>文件中<br><code>&quot;package&quot;: &quot;electron-packager C:/Users/liang/Desktop/test/window-app win-app&quot;</code><br><code>electron-packager</code>后是整个项目的地址以及生成<code>.exe</code>文件的名字<br>这样electron会封装React项目生成和当前电脑操作系统匹配的桌面程序</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React读取和写入Excel表格</title>
    <link href="/2020/02/03/React%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5Excel%E8%A1%A8%E6%A0%BC/"/>
    <url>/2020/02/03/React%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5Excel%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>想用React纯前端来读取并写入一个Excel文件可以通过<code>React-xlsx</code>包来实现<br><a href="https://github.com/SheetJS/sheetjs" target="_blank" rel="noopener">https://github.com/SheetJS/sheetjs</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ npm install xlsx</code></pre><p>在文件头部引入XLSX包</p><pre><code class="javascript">import * as XLSX from &#39;xlsx&#39;;</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>首先通过HTML标签来上传一个文件，并绑定一个事件<code>onImportExcel</code></p><pre><code class="html">&lt;input type=&quot;file&quot; accept=&quot;.xlsx, .xls&quot; onChange={this.onImportExcel}&gt;</code></pre><pre><code class="javascript">onImportExcel = (file) =&gt; {    // 获取选择的文件    const {files} = file.target;    const fileReader = new FileReader();    fileReader.onload = event =&gt; {        try {            const {result} = event.target;            const data = [];            // 通过xlsx获取文件二进制流            const workbook = XLSX.read(result, {type: &#39;binary&#39;});            // 获取第一个表格名            var sheet_name = workbook.SheetNames[0];            // 获取Excel表中第一个sheet            var worksheet = workbook.Sheets[sheet_name];            // 获取表格内所有数据            data = XLSX.utils.sheet_to_json(worksheet, {header: 1});        } catch(e) {            // console.log(&quot;ERROR!&quot;);        }    };    fileReader.readAsBinaryString(files[0]);}</code></pre><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>通过<code>XLSX.utils</code>中的方法可以创建一个新的workbook并向其中写入数据</p><pre><code class="javascript">// 创建一个新的workbookvar wb = XLSX.utils.book_new();var ws_name = &quot;Sheet1&quot;;// 创建sheetvat ws_data = [    [&quot;Cell-A-1&quot;, &quot;Cell-B-1&quot;],    [&quot;Data&quot;, &quot;Data&quot;]];// 将ws_data转化成worksheetvar ws = XLSX.utils.aoa_to_sheet(ws_data);// 将新的sheet添加到workbook中XLSX.utils.book_append_sheet(wb, ws, ws_name);// 最后输出生成的Excel文件XLSX.writeFile(workbook, &#39;out.xlsx&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie Structure</title>
    <link href="/2019/10/28/Trie-Structure/"/>
    <url>/2019/10/28/Trie-Structure/</url>
    
    <content type="html"><![CDATA[<p>Trie是一种特殊的Tree形式，用来存储String数据，每一个Trie node代表了<code>a string</code>。Trie结构多用于查找prefix。<br>一般的，我们使用创建一个TrieNode来表示Trie结构中的一个节点</p><pre><code class="java">class TrieNode {    public static final size = 26;    public TireNode[] children = new TrieNode[size];    public boolean isWord;}// Usage: // Initialization: TrieNode root = new TrieNode();</code></pre><p>因为我们使用了<code>array</code>来记录每一个TrieNode的子节点，那么访问每一个子节点就十分方便，但因为不是每一个节点都会包含所有26个字母的子节点，所以可能会浪费比较多的空间</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code class="java">public void insert(String word) {    TrieNode current = root;    // 对当前单词的每一个Char进行遍历    for(int i = 0; i &lt; word.length(); i++) {        Character c = word.charAt(i);        if(current.children[c - &#39;a&#39;] == null) {            // 如果当前c不在子节点中，我们更新子节点            current.children[c - &#39;a&#39;] = c;        }        current = current.children[c - &#39;a&#39;];    }    // isWord表示当前节点是插入的word的截至    current.isWord = true;}</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
