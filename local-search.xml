<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>减小Electron应用打包后的体积</title>
    <link href="/2020/02/11/%E5%87%8F%E5%B0%8FElectron%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BD%93%E7%A7%AF/"/>
    <url>/2020/02/11/%E5%87%8F%E5%B0%8FElectron%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BD%93%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p>Electron可以说是给那些对前端技术比较熟悉的开发人员进行桌面应用开发的一个比较好的框架<br>但是Electron打包之后的文件大小实在是有点过于庞大，对于一个没有太多功能的app居然达到了300mb！<br>在对打包后的文件进行查询后发现占用体积最大的部分就是React应用中的<code>node_modules</code><br>因为使用的是<code>electron-packager</code>进行的打包，所以打包后的程序基本上是完整拷贝了<code>node_modules</code>中的所有文件<br>但是除了React的那部分外，还有很大的一部分空间被占用了</p><blockquote><p>The downside of the Electron approach is that each app comes with a copy of two large software frameworks, Node.js and Chromium.<br>So, each Electron app essentially carries an operating system with it.</p></blockquote><p>就像<a href="https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297" target="_blank" rel="noopener">Put your Electron app on a diet with Electrino</a>这篇文章讲的那样，因为Electron的内核使用的是<code>Chromium</code>同时还加载了所有的<code>node_modules</code>，基本上一款Electron应用里面就用到了两大框架，所以即便是一个简单的<code>hello_world.js</code>被Electron打包出来后都会有100mb以上的大小</p><h3 id="减小node-modules的体积"><a href="#减小node-modules的体积" class="headerlink" title="减小node_modules的体积"></a>减小node_modules的体积</h3><p>因为<code>Chromium</code>内核的文件是不能删除的，而在打包过程中产生的文件也是不能删掉的，所以比较现实的方法就是尽可能的减少<code>node_modules</code>里面的文件</p><h4 id="删除多余的package"><a href="#删除多余的package" class="headerlink" title="删除多余的package"></a>删除多余的package</h4><p>在开发的过程中，有可能会使用一些新的依赖项来顶替掉原来使用的依赖项，这个时候<code>node_modules</code>就会越来越大，所以在<code>package.json</code>文件中会有一大长串的<code>dependencies</code>，但是在应用中却没有被引用<br>这时候就需要清理<code>node_modules</code>，比较暴力的方法就是删除整个文件，然后<code>npm install</code>来安装所有在<code>package.json</code>中的依赖项。同时也可以使用<code>npm prune --</code>指令<br><code>prune</code>主要是来移除无关的包，可以提供需要被移除的包名</p><pre><code>npm prune [[&lt;@scope&gt;/]&lt;pkg&gt;...] [--production] [--dry-run] [--json]</code></pre><h4 id="将dependencies转移devDependencies中"><a href="#将dependencies转移devDependencies中" class="headerlink" title="将dependencies转移devDependencies中"></a>将dependencies转移devDependencies中</h4><p>在安装一个包的时候，可以有以下两种方法</p><pre><code>npm install module-name --savenpm install module-name --save-dev</code></pre><p>第一种是将模块安装到<code>dependencies</code>中<br>第二种是将模块安装到<code>devDependencies</code>中</p><p>dependencies代表的是生产环境，也就是程序运行时所需要调用到的包<br>而devDependencies代表的是开发环境，可以理解为开发程序中所需要的包</p><p>比如Electron就是开发环境，我们需要Electron来将我们的React App打包成桌面应用，但是我们在运行我们的桌面应用时是不需要Electron的，所以Electron可以被放在<code>devDependencies</code><br>再或者<code>react-router</code>，是React应用进行页面跳转用的模块，因为我们程序运行需要页面跳转，如果程序无法调用到这个模块，那就会报错，所以这个模块就是生产环境</p><p>在Electron打包的过程中，是不会将<code>devDependencies</code>中的模块复制到打包文件中的，所以将一些开发用的模块放到<code>devDependencies</code>中也可以起到减小最终程序大小的效果</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>还有一些方法比如<code>electron-builder</code>的two package.json方法，因为我使用的不是这个打包方式，所以也不太清楚这种方法的效果<br>另一种方法是之前提到的文章的作者开发了一款叫做<code>Electrino</code>的框架，用的是操作系统自带的浏览器内核，比如Windows系统就使用的是Microsoft Edge Browser来作为内核，但是由于这个框架还在开发中，有很多api都不太全，但是可以一试</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，使用Electron这种跨平台框架来开发桌面应用本来就是一中不算太正确或者不太成熟的做法，毕竟很多桌面开发框架都很成熟而且速度很快。但Electron的确给熟悉前端技术的开发者一个好的平台来开发桌面应用<br>毕竟省去了搞服务器和公共域名的麻烦，而且也不用用户自己输入<code>npm start</code>来运行Web app</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297" target="_blank" rel="noopener">https://medium.com/dailyjs/put-your-electron-app-on-a-diet-with-electrino-c7ffdf1d6297</a><br><a href="https://stackoverflow.com/questions/47597283/electron-package-reduce-the-package-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/47597283/electron-package-reduce-the-package-size</a><br><a href="https://stackoverflow.com/questions/21122342/how-to-clean-node-modules-folder-of-packages-that-are-not-in-package-json" target="_blank" rel="noopener">https://stackoverflow.com/questions/21122342/how-to-clean-node-modules-folder-of-packages-that-are-not-in-package-json</a><br><a href="https://www.jianshu.com/p/de3f9a53d2a9" target="_blank" rel="noopener">https://www.jianshu.com/p/de3f9a53d2a9</a></p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React中input标签-受控组件</title>
    <link href="/2020/02/10/React%E4%B8%ADinput%E6%A0%87%E7%AD%BE-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/02/10/React%E4%B8%ADinput%E6%A0%87%E7%AD%BE-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Reference:<br><a href="https://segmentfault.com/a/1190000002675685" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002675685</a><br><a href="https://segmentfault.com/q/1010000008144015" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008144015</a><br><a href="https://stackoverflow.com/questions/43556212/failed-form-proptype-you-provided-a-value-prop-to-a-form-field-without-an-on" target="_blank" rel="noopener">https://stackoverflow.com/questions/43556212/failed-form-proptype-you-provided-a-value-prop-to-a-form-field-without-an-on</a><br><a href="http://shouce.jb51.net/react/tips/controlled-input-null-value.html" target="_blank" rel="noopener">http://shouce.jb51.net/react/tips/controlled-input-null-value.html</a></p><p>今天在做一个用户能够更新数据的表单的时候遇到了几个问题</p><h3 id="input-受控组件"><a href="#input-受控组件" class="headerlink" title="input 受控组件"></a>input 受控组件</h3><p>在表单中有一个<code>input</code>标签，我希望是在页面加载的时候首先从后端数据库获取当前页面对应的数据，并将某个数据放入这个<code>input</code>标签中。<br>之后用户能够更改这个<code>input</code>的value并且能够将表单中所有更新的值都在数据库端进行更新。</p><p>在给<code>&lt;input value={this.state.value}&gt;</code>赋值之后控制台出现了以下的warning</p><blockquote><p>Warning: A component is changing an uncontrolled input of type text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component.</p></blockquote><p>随即查了一下。所谓<code>controlled component - 受控组件</code>在这里指的就是被赋了值的<code>input</code>标签，也就是:</p><pre><code class="html">&lt;input value={this.state.some_value}&gt;</code></pre><p>这时候组件受控，所以<code>input</code>标签中会一直显示所赋予的值。<br>当页面被渲染之后，用户是无法更改<code>input</code>标签中的值的，这也是我尝试去删除或者修改这个<code>input</code>标签都无效的原因</p><p>如果想要随着用户的输入而改变值的话，可以使用<code>onChange</code>事件:</p><pre><code class="html">&lt;input value={this.state.some_value} onChange={e =&gt; this.setState({some_value: e.target.value})}&gt;</code></pre><p>这样，<code>input</code>标签就是可以更改的了，而且能够跟着用户的输入来更改<code>state</code>中对应的值</p><p>后来在添加了<code>onChange</code>事件后发现仍然无法删除或者修改<code>input</code>中的内容，并且控制台也没有任何报错或者警告<br>查找了半天后发现原来<code>input</code>标签中赋值的对象和<code>onChange</code>事件中改变值后更新的对象不是同一个<br>也就是每次被修改的并不是<code>input</code>内的值，所以才会出现无论怎么改动值都不会更新的情况</p><h3 id="input-defaultValue"><a href="#input-defaultValue" class="headerlink" title="input defaultValue"></a>input defaultValue</h3><p>后来在给一个<code>input</code>设置默认且不能更改的值时遇到了以下warning:</p><blockquote><p>Warning: Failed prop type: You provided a <code>value</code> prop to a form field without an <code>onChange</code> handler. This will render a read-only field. If the field should be mutable use <code>defaultValue</code>. Otherwise, set either <code>onChange</code> or <code>readOnly</code>.</p></blockquote><p>这里是当一个<code>input</code>标签中的内容不会被用户所更改时，应该将<code>value</code>改成<code>defaultvalue</code>以此来达到read-only的效果<br>如果用户需要对这个标签进行修改那么就像之前说的那样加上<code>onChange</code>事件</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm安装electron时卡在node install.js的解决办法</title>
    <link href="/2020/02/07/npm%E5%AE%89%E8%A3%85electron%E6%97%B6%E5%8D%A1%E5%9C%A8node-install-js%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2020/02/07/npm%E5%AE%89%E8%A3%85electron%E6%97%B6%E5%8D%A1%E5%9C%A8node-install-js%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在使用npm安装electron时出现了卡在<code>node install.js</code>指令的情况<br>不出意外应该是electron的安装源被墙掉了，所以需要给npm指定镜像的安装地址</p><p>解决方法是在<code>~/.npmrc</code>文件中添加如下指令即可</p><pre><code>; registry=https://registry.npm.taobao.org; electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;</code></pre><p><code>~/.npmrc</code>是npm的配置文件，如果不知道位置可以通过如下指令直接修改</p><pre><code>npm config edit</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Electron封装React为桌面程序</title>
    <link href="/2020/02/07/%E7%94%A8Electron%E5%B0%81%E8%A3%85React%E4%B8%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/02/07/%E7%94%A8Electron%E5%B0%81%E8%A3%85React%E4%B8%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://blog.csdn.net/qq_25881261/article/details/81559794" target="_blank" rel="noopener">https://blog.csdn.net/qq_25881261/article/details/81559794</a><br><a href="https://segmentfault.com/a/1190000014030465" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014030465</a><br><a href="https://www.electronjs.org/docs/tutorial/first-app" target="_blank" rel="noopener">https://www.electronjs.org/docs/tutorial/first-app</a><br><a href="https://github.com/electron/electron-packager" target="_blank" rel="noopener">https://github.com/electron/electron-packager</a></p><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>使用React可以很高效得来做网页开发，但是在无法将React项目部署到服务器上时，让用户在cmd中输入启动React项目的指令来运行网页是不现实的<br>好在有Electron，可以将React项目封装成为桌面应用。对于用户来说使用起来更加得简单</p><h3 id="Electron简介"><a href="#Electron简介" class="headerlink" title="Electron简介"></a>Electron简介</h3><p>引用官方文档介绍</p><blockquote><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p></blockquote><h3 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h3><p>官方文档的推荐安装方法是将<code>electron</code>安装为项目的开发依赖项，这样可以在不同的app中使用不同的electron版本</p><pre><code class="bash">npm install --save-dev electron</code></pre><h2 id="在React项目中添加Electron"><a href="#在React项目中添加Electron" class="headerlink" title="在React项目中添加Electron"></a>在React项目中添加Electron</h2><h3 id="配置main-js"><a href="#配置main-js" class="headerlink" title="配置main.js"></a>配置main.js</h3><p>首先在React项目下创建一个<code>main.js</code>文件<br>项目结构类似于:</p><pre><code>---node_modules---public---src---main.js  //新建文件---package.json---package-lock.json---README.md</code></pre><p>在<code>main.js</code>中复制文档中的代码段来配置桌面应用的启动与关闭</p><blockquote><p><a href="https://www.electronjs.org/docs/tutorial/first-app" target="_blank" rel="noopener">https://www.electronjs.org/docs/tutorial/first-app</a></p></blockquote><pre><code class="javaScript">const { app, BrowserWindow } = require(&#39;electron&#39;)function createWindow () {     // 创建浏览器窗口  const win = new BrowserWindow({    width: 800,    height: 600,    webPreferences: {      nodeIntegration: true    }  })  // 加载build文件中的index.html  /*  win.loadURL(url.format({    pathname: path.join(__dirname, &#39;./build/index.html&#39;),    protocol: &#39;file:&#39;,    slashes: true  }))  */  // 加载React应用 -热更新中使用  // win.loadURL(&#39;http://localhost:3000/&#39;);  // and load the index.html of the app.  win.loadFile(&#39;index.html&#39;)  // 打开开发者工具  win.webContents.openDevTools()}// This method will be called when Electron has finished// initialization and is ready to create browser windows.// 部分 API 在 ready 事件触发后才能使用。app.whenReady().then(createWindow)// Quit when all windows are closed.app.on(&#39;window-all-closed&#39;, () =&gt; {  // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，  // 否则绝大部分应用及其菜单栏会保持激活。  if (process.platform !== &#39;darwin&#39;) {    app.quit()  }})app.on(&#39;activate&#39;, () =&gt; {  // 在macOS上，当单击dock图标并且没有其他窗口打开时，  // 通常在应用程序中重新创建一个窗口。  if (BrowserWindow.getAllWindows().length === 0) {    createWindow()  }})// In this file you can include the rest of your app&#39;s specific main process// code. 也可以拆分成几个文件，然后用 require 导入。</code></pre><p>如果是在React开发过程中需要查看electron更新需要使用<code>win.loadURL(&#39;http://localhost:3000/&#39;);</code>表示桌面文件会调用<code>localhost:3000</code>运行的内容<br>如果是要调用打包好的React项目，那么需要使用<code>win.loadURL(url.format({pathname: path.join(__dirname, &#39;./build/index.html&#39;)})),</code>来调用<code>build</code>文件夹中的<code>index.html</code></p><h3 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h3><p>因为React项目是使用<code>npm start</code>来启动，所以我们需要在<code>package.json</code>文件中配置Electron的启动指令</p><pre><code class="json">{  &quot;name&quot;: &quot;window-app&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  &quot;homepage&quot;: &quot;.&quot;,      // &quot;homepage&quot;保证build后的React项目可以运行  &quot;main&quot;: &quot;main.js&quot;,    // 在此处添加main.js  &quot;dependencies&quot;: {    &quot;@testing-library/jest-dom&quot;: &quot;^4.2.4&quot;,    &quot;@testing-library/react&quot;: &quot;^9.4.0&quot;,    &quot;@testing-library/user-event&quot;: &quot;^7.2.1&quot;,    &quot;react&quot;: &quot;^16.12.0&quot;,    &quot;react-dom&quot;: &quot;^16.12.0&quot;,    &quot;react-scripts&quot;: &quot;3.3.1&quot;  },  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;,    &quot;electron-start&quot;: &quot;electron .&quot;,     // electron启动指令    &quot;package&quot;: &quot;electron-packager C:/Users/liang/Desktop/test/window-app win-app&quot;   // electron打包指令  },  &quot;eslintConfig&quot;: {    &quot;extends&quot;: &quot;react-app&quot;  },  &quot;browserslist&quot;: {    &quot;production&quot;: [      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ],    &quot;development&quot;: [      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ]  },  &quot;devDependencies&quot;: {    &quot;electron&quot;: &quot;^8.0.0&quot;,    &quot;electron-packager&quot;: &quot;^14.2.0&quot;  }}</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>在两个命令行窗口中分别运行</p><pre><code>npm start</code></pre><pre><code>npm run electron-start</code></pre><p>这样就可以看到electron生成的桌面应用，并且是保持React项目的热更新</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="打包React"><a href="#打包React" class="headerlink" title="打包React"></a>打包React</h3><p>在开发完React项目后需要需要将项目打包以此来是的electron桌面程序能够脱离服务器来使用<br>这里需要在<code>package.json</code>文件中添加<code>&quot;homepage&quot;:&quot;.&quot;</code>来保证所有的路径都能被访问到<br>打包React:<br><code>npm run build</code><br>打包后会在当前目录下创建<code>build</code>文件夹，打开文件夹后运行<code>index.html</code>，如果出现内容则证明React项目打包成功</p><h3 id="打包Electron"><a href="#打包Electron" class="headerlink" title="打包Electron"></a>打包Electron</h3><p>官方文档上说常用的打包插件有<code>electron-forg</code>,<code>electron-packager</code>和<code>electron-builder</code><br>这里使用<code>electron-packager</code><br>首先安装</p><pre><code>npm install electron-packager --save-devnpm install electron-packager -g</code></pre><p>electron-packager的指令是：</p><pre><code>electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</code></pre><p>这里可以简化并添加到<code>package.json</code>文件中<br><code>&quot;package&quot;: &quot;electron-packager C:/Users/liang/Desktop/test/window-app win-app&quot;</code><br><code>electron-packager</code>后是整个项目的地址以及生成<code>.exe</code>文件的名字<br>这样electron会封装React项目生成和当前电脑操作系统匹配的桌面程序</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React读取和写入Excel表格</title>
    <link href="/2020/02/03/React%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5Excel%E8%A1%A8%E6%A0%BC/"/>
    <url>/2020/02/03/React%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5Excel%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>想用React纯前端来读取并写入一个Excel文件可以通过<code>React-xlsx</code>包来实现<br><a href="https://github.com/SheetJS/sheetjs" target="_blank" rel="noopener">https://github.com/SheetJS/sheetjs</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ npm install xlsx</code></pre><p>在文件头部引入XLSX包</p><pre><code class="javascript">import * as XLSX from &#39;xlsx&#39;;</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>首先通过HTML标签来上传一个文件，并绑定一个事件<code>onImportExcel</code></p><pre><code class="html">&lt;input type=&quot;file&quot; accept=&quot;.xlsx, .xls&quot; onChange={this.onImportExcel}&gt;</code></pre><pre><code class="javascript">onImportExcel = (file) =&gt; {    // 获取选择的文件    const {files} = file.target;    const fileReader = new FileReader();    fileReader.onload = event =&gt; {        try {            const {result} = event.target;            const data = [];            // 通过xlsx获取文件二进制流            const workbook = XLSX.read(result, {type: &#39;binary&#39;});            // 获取第一个表格名            var sheet_name = workbook.SheetNames[0];            // 获取Excel表中第一个sheet            var worksheet = workbook.Sheets[sheet_name];            // 获取表格内所有数据            data = XLSX.utils.sheet_to_json(worksheet, {header: 1});        } catch(e) {            // console.log(&quot;ERROR!&quot;);        }    };    fileReader.readAsBinaryString(files[0]);}</code></pre><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>通过<code>XLSX.utils</code>中的方法可以创建一个新的workbook并向其中写入数据</p><pre><code class="javascript">// 创建一个新的workbookvar wb = XLSX.utils.book_new();var ws_name = &quot;Sheet1&quot;;// 创建sheetvat ws_data = [    [&quot;Cell-A-1&quot;, &quot;Cell-B-1&quot;],    [&quot;Data&quot;, &quot;Data&quot;]];// 将ws_data转化成worksheetvar ws = XLSX.utils.aoa_to_sheet(ws_data);// 将新的sheet添加到workbook中XLSX.utils.book_append_sheet(wb, ws, ws_name);// 最后输出生成的Excel文件XLSX.writeFile(workbook, &#39;out.xlsx&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie Structure</title>
    <link href="/2019/10/28/Trie-Structure/"/>
    <url>/2019/10/28/Trie-Structure/</url>
    
    <content type="html"><![CDATA[<p>Trie是一种特殊的Tree形式，用来存储String数据，每一个Trie node代表了<code>a string</code>。Trie结构多用于查找prefix。<br>一般的，我们使用创建一个TrieNode来表示Trie结构中的一个节点</p><pre><code class="java">class TrieNode {    public static final size = 26;    public TireNode[] children = new TrieNode[size];    public boolean isWord;}// Usage: // Initialization: TrieNode root = new TrieNode();</code></pre><p>因为我们使用了<code>array</code>来记录每一个TrieNode的子节点，那么访问每一个子节点就十分方便，但因为不是每一个节点都会包含所有26个字母的子节点，所以可能会浪费比较多的空间</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code class="java">public void insert(String word) {    TrieNode current = root;    // 对当前单词的每一个Char进行遍历    for(int i = 0; i &lt; word.length(); i++) {        Character c = word.charAt(i);        if(current.children[c - &#39;a&#39;] == null) {            // 如果当前c不在子节点中，我们更新子节点            current.children[c - &#39;a&#39;] = c;        }        current = current.children[c - &#39;a&#39;];    }    // isWord表示当前节点是插入的word的截至    current.isWord = true;}</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
